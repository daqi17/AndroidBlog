## 端口号

数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器。而传输层中，端口号用来标识同一台计算机进行通信的不同应用程序。（也被称为程序地址）

### 通过IP地址、端口号、协议号进行通信识别

> TCP/IP 和 UDP/IP通信中通常采用5个信息来识别一个通信。分别为：源IP地址、目标IP地址、协议号、源端口号 和 目标端口号。

## UDP

> UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。
>
> 即便出现网络拥堵的情况下，UDP也无法将进行流量控制，那么不得不交由才有UDP的应用程序去处理。

UDP经常用于以下几个方面：

* 包总量较少的通信（DNS、SNMP等）
* 视频、音频等多媒体通信（即时通信）
* 限定于LAN等特定网络中的应用通信
* 广播通信（广播、多播）

## TCP

​		TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

​		TCP作为一种面向有连接的协议，只有在确认通信端存在时才会发送数据，从而可以控制通信流量的浪费。依靠TCP的这些机制，IP这种无连接的网络上也能够实现高可靠性的通信。

### 连接

>  ​	连接指各种设备、线路，或网络中进行通信的两个应用程序为了相互传递消息而专有的、虚拟的通信线路，也叫做虚拟线路。

​		一旦建立连接，进行通信的应用程序只使用这个虚拟的通信线路发送和接收数据，就可以保障信息的传输。

TCP则负责控制连接的建立、断开、保持等管理工作。

### TCP特点

TCP通过检验和、序列号、确认应答、重发控制、连接控制以及窗口控制等机制实现可靠性传递。

### 确认应答

> 在TCP中，当发送端的数据到达接收主机时，接收端会返回一个已收到消息的通知。这种消息叫做**确认应答**。

​		TCP通过肯定的确认应答实现可靠的数据传输。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端，反制，则数据丢失的可能性很大。

![](C:\Users\deling\Desktop\传输层\确认应答.png)

​	未收到确认应答并不意味着数据一定丢失，也有可能是数据对方已经收到只是返回的确认应答在途中丢失。此时，发送端仍会对此数据进行重发，**接收端也会再次发送接收到此数据的确认应答。同时，接收方会将重复接收的数据丢弃。**

​		也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达。源发送主机只需要按照机制重发数据即可，但对于目标主机会重复收到相同的数据，且必须得放弃重复的数据包。

### 序列号

​		确认应答处理、重发控制以及重复控制等功能都可以通过序列号实现。**序列号是按顺序给发送数据的每一个字节都标上号码的编号。**接收端查询接受数据TCP首部中的序列号和数据长度，将自己下一步应该接受的序列号作为确认应答返送回去。(即没有收到之前不会更改确认应答号)

![](C:\Users\deling\Desktop\传输层\序列号与确认应答.png)

`TCP的数据长度并未写入TCP首部。实际通讯中求得TCP包的长度的计算公式是: IP首部中的数据包长度 - IP首部长度 - TCP首部长度。`

### 重发超时

> 重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重发。

​		TCP要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在发送包时都会计算往返时间（RTT）及其偏差。将这个往返时间和偏差相加，重发超时的时间就是比这个总和要稍大一点的值。

​		在BSD的Unix和Window系统中，超时都以0.5秒单位进行控制，因此重发超时都是0.5秒的倍数。对于最初的数据包还不知道往返时间，所以其重发超时一般设置为6秒左右。

​		数据重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭了连接并且通知应用通信异常强制终止。

### 连接管理

面向有连接是指在数据通信开始之前先做好通信两端之间的准备工作。

​		UDP不检查对端是否可以通信，直接将UDP包发送出去。

​		**TCP则会在发送数据之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答。**（TCP中发送第一个SYN包的一方叫做客户端，接收这个的一方叫做服务器。）如果对端发来确认应答，则认为可以进行通信。如果对端应答未达到，就不会进行数据通信。此外，**TCP在通信结束时会进行断开连接的处理（FIN包）。**

![](C:\Users\deling\Desktop\传输层\SYN&FIN.png)

### TCP以段为单位发送数据

​		在建立TCP连接的同时，可以确定发送数据包的单位（称为：“最大消息长度（MSS）”）。最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度。（即MSS 跟 路径MTU 差不多大小。）

> TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位。

​		MSS是在三次握手的时候，在两端主机之间被计算出。两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小。然后会在两者之间选择一个较小的值投入使用。

![](C:\Users\deling\Desktop\传输层\MSS.png)

### 利用窗口控制提高速度

`背景：TCP以1个段的单位，每发一个段进行一次确认应答的处理。但是包的往返时间越长通信性能就越低。`

​		TCP引入了窗口这个概念，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短。（即发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送。）

![](C:\Users\deling\Desktop\传输层\窗口控制.png)

> 窗口的大小是指无需等待确认应答而可以继续发送数据的最大值。

​		在窗口内的数据即便没有收到确认应答也可以被发送出去。但在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。（发送端主机得设置缓存保留这些待被重传的数据，直到收到它们的确认应答。）

​		在收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这种机制也被称为滑动窗口控制。滑动窗口以外的部分包括尚未发送的数据以及已经确认对端已收到的数据。

![](C:\Users\deling\Desktop\传输层\窗口滑动.png)

### 窗口控制与重发控制

​		在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。而使用了窗口控制，某些确认应答即便丢失也无需重发。（接收端确定接受到数据之后，才会更改确认应答号，如果收到后面段的确认应答，即便收不到前面段的确认应答，也可以认为前面的段已被接收。）

![](C:\Users\deling\Desktop\传输层\窗口控制2.png)

​		当某一个报文段丢失后，发送端会一直收到序号为1001的确认应答。因此，窗口比较大，又出现报文段丢失的情况下，同一序号的确认应答将会被重复不断地返回。

![](C:\Users\deling\Desktop\传输层\重复应答.png)

​		发送端如果连续3次收到同一个确认应答，就会将其所有对应的数据进行重发。该机制对比超时管理机制更高效，因此被称作**高速重发控制**。

### 流控制

`背景：接收端在为数据包做其他处理时会耗费一些时间，甚至在高负荷的情况下无法接收任何数据。如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的无端浪费。`

为此，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量——**流控制**

> 接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。
>
> 该大小限度就被称作窗口大小，即**窗口大小的值就是由接收端主机决定的。**

> 即流控制用于控制窗口的大小，而且由接收端控制。

​		TCP首部中，专门有一个字段用来通知窗口大小。这个字段的值越大，说明网络的吞吐量越高。**当接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据的发送量。**

​		即发送端主机会根据接收端主机得指示，对发送数据的量进行控制，这就形成了一个完整的TCP流控制（流量控制）

![](C:\Users\deling\Desktop\传输层\流控制.png)

​		当接收端缓冲区即满，会暂时停止接收数据。发送端主机会时不时的发送一个叫做窗口探测的数据段（此数据段仅含一个字节）以获取最新的窗口大小信息。也可防止窗口的更新通知在传输途中丢失，导致无法继续通信。

### 拥塞控制

`背景：计算机网络都处在一个共享的环境，因此会出现因为其他主机之间的通信使得网络拥堵。而在网络拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。TCP为了防止该问题的出现，在通信一开始时，就会通过慢起动的算法得出的数值，对发送数据量进行控制。`

​		TCP为了防止该问题的出现，在通信一开始时就会通过一个叫慢启动的算法得出数值，对发送数据量进行控制。

![](C:\Users\deling\Desktop\传输层\阻塞窗口.png)

1. 为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞接口”的概念。慢启动时，拥塞窗口的大小设置为1个数据段（1MSS）发送数据，之后每收到一次确认应答（ACK），拥塞窗口的值就加1。
2. 在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小的值，发送比起还要小的数据量。
3. 如果触发超时机制重发数据段，阻塞窗口的初始值可以设置为1以后再进行慢启动修正。

#### 慢启动阀值

`背景：但随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况激增甚至导致网络拥塞的发生。`

因此为慢启动引入了慢启动阀值的概念。只有拥塞窗口的值超过这个阀值，在每收到一次确认应答时，只允许以下面这种比例放大拥塞窗口：

**1 个 数字段的字节数 / 拥塞窗口（字节） * 1个数据段字节数**

![](C:\Users\deling\Desktop\传输层\阻塞窗口2.png)

​		阻塞窗口越大，确认应答的数目也会增加。不过随着每收到一个确认应答，其涨幅也会逐渐减少，甚至小过比一个数据段还要小的字节数。

​		TCP刚开始通信时，并没有设置相应的慢启动阀值（与窗口最大值相同）。而是在超时重发时，才会设置为当时**拥塞窗口**一半的大小。

​		由重复应答确认应答进行高速重发控制时，慢启动阀值的大小被设置为**当时窗口**大小的一半（严格说：是设置为为“实际已发送但未收到确认应答的数据量”的一半）。(非阻塞窗口)

​		当TCP通信开始以后，网络吞吐量会逐渐上升，但随着网络拥堵的发生吞吐量也会急速下降。于是会再次进入吞吐量慢慢上升的过程。

### 确认应答延迟

​		接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的较少的窗口。因为刚接收完数据，缓冲区已满。当某个接收端收到这个窗口的通知以后，会以它为上限发送数据，从而又降低了网络的利用率。

​		因此，收到数据以后并不立即返回确认应答，而是延迟一段时间的机制。事实上，不必为每一段数据段都进行一次确认应答。TCP采用滑动窗口的控制机制，因此通常确认应答少一些也无妨。TCP文件传输中，绝大多数是每两个数据段返回一个确认应答。

### 捎带应答

​		根据应用层协议，发送出去的消息达到对端，对端进行处理以后，会返回一个回执。TCP的确认应答和回执数据可以通过一个包发送，这种方式叫做捎带应答。

​		如果接收到数据以后立刻返回确认应答，就无法实现捎带应答。而是将数据所接收的数据传给应用处理生成返回数据以后再进行发送请求为止，必须一直等待确认应答的发送。（即没有启动延迟确认应答就无法实现捎带应答。）

## DCCP（数据报拥塞控制协议）

> DCCP是一个辅助UDP的崭新的传输层协议。
>
> UDP没有拥塞控制机制。

当UDP发送大量数据包时，极易出现问题。但阻塞控制极难融合至协议中：

* 与UDP一样，不能提供发送数据的可靠性传输。
* 面向连接。具备建立连接与断开连接的处理。（在建立和断开连接上是具有可靠性）
* 能够根据网络拥堵情况进行拥塞控制。使用DCCP应用可以根据自身特点选择两种方法进行拥塞控制。
  * 类似TCP
  * TCP友好升级控制（流控制的一种，相比TCP的窗口控制，可以TFRC是针对声频和视频等多媒体的一种控制）
* 为了进行拥塞控制，接收端收到包以后返回确认应答（ACK）。该确认应答将被用于重发与否的控制。

## UDP首部

![](C:\Users\deling\Desktop\传输层\UDP头部.png)

* 源端口号
  * 表示发送端端口号，字段长16位。
  * 没有源端口号的时候该字段的值设置为0。可用于不需要返回的通信中（如发送更新信息）。
* 目标端口号
  * 表示接收端端口，字段长度16位。
* 包长度
  * 该字段保存了UDP首部的长度跟数据的长度之和。字段长8字节
* 校验和
  * 校验和是为了提供可靠的UDP首部和数据而设计。
  * 校验和字段中填入0表示不进行校验和计算，协议处理的开销就会降低。

接收主机在收到UDP数据报以后，从IP首部获知IP地址信息构造UDP伪首部，再进行校验和计算。

为什么在进行校验和计算时，也要计算UDP伪首部呢？

​	因为TCP/IP中识别一个进行通信的应用需要5大要素，而UDP的首部中只包含其中的“源端口”和“目标端口”，余下的3项包含在IP首部中。

## TCP首部

![](C:\Users\deling\Desktop\传输层\TCP头部.png)

* 源端口号
  * 表示发送端端口号，字段长16位。
* 目标端口号
  * 表示接收端端口号，字段长16位。
* 序列号（有时也叫序号）
  * 字段长32位
  * 序列号是指发送数据的位置。每发送一次数据，就累加一次该数据字节数的大小。
  * 序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后将每次转发过去的字节数累加到初始值上表示数据的位置。
  * 建立连接和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。
* 确认应答号
  * 字段长32位
  * 指下一次应该收到的数据的序列号。（即指已收到确认应答号前一位为止的数据）
  * 发送端收到这个确认应答以后可以认为这个序号以前的数据都已经被正常接收。
* 数据偏移
  * 字段长4位，单位为4字节。
  * 该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，也可以把它当作TCP首部的长度。
  * 如果该字段的值设置为5，那说明从TCP包的最一开始到20字节为止都是TCP首部，余下的部分为TCP数据。
* 控制位
  * 字段长8位
  * 从左到右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。
  * ![](C:\Users\deling\Desktop\传输层\TCP控制位.png)
* 窗口大小
  * 字段长16位。
  * 用于通知**从相同TCP首部的确认应答号所指位置开始能够接收的数据大小。**
  * 如果窗口的值为0，则表示可以发送窗口探测，以了解最新的窗口大小。（数据必须是1个字节）
* 校验和
  * TCP和UDP的校验和相似，区别在于UDP的校验和无法关闭。
* 紧急指针
  * 字段长16位
  * 只有在URG为1时有效。（URG为1时表示该包中有需要紧急处理的数据）
  * 该字段的数值表示本报文段中紧急数据的指针。
* 选项
  * 类型2的MSS选项用于建立连接时决定最大段长度的情况。
  * 类型为2的窗口扩大，是一个用来改善TCP吞吐量的选项。