## 互联网层

> 该层主要有 IP 和 ICMP 两个协议组成。
>
> 主要作用：实现终端节点之间的通信。

​		数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。

​		网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。

### 主机和节点

主机

> 配置有IP地址，但是不进行路由控制的设备

路由器

> 即配有IP地址又具有路由控制力的设备

**节点则是主机和路由器的统称。**

### 网络层和数据链路层的关系

> 数据链路层提供直连两个设备之间的通信功能。
>
> 网络层的IP则负责在没有直连的两个网络之间进行通信传输。

## IP基础知识

> IP地址用于：连接到网络中的所有主机识别出进行通信的目标地址。
>
> 在TCP/IP通信中所有主机或路由器必须设定自己的IP地址。

### 路由控制

> 路由控制是指将分组数据发送到最终目标地址的功能。
>
> 即使网络非常复杂，也可以通过路由控制确定到达目标地址的通道。

​		一旦这个路由器控制的运行出现异常，分组数据极有可能“迷失”，无法到达目标地址。

#### 跳

> 跳指网络种的一个区间。

​		IP包正是在网络中一个个跳间被转发。在每一个区间内决定着包在下一跳被转发的路径。

​		一跳是指利用数据链路层以下分层的功能传输数据帧的一个区间。

#### 路由控制表

> 为了将数据包发给目标主机，所有主机都维护着一张路由控制表。

该表记录IP数据在下一步应该发给哪个路由器。

### IP属于面向无连接型

> IP地址属于面向无连接型。即在发包之前，不需要建立与对端目标地址之间的连接。

​		IP采用无连接的原因是：一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂，而且每次通信之前都要事先建立连接，又会降低处理速度。

## IP地址的基础知识

### IP地址分类

​	IP地址分为四个级别，分别为A类、B类、C类、D类。它根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。

* A类地址
  * IP地址是首位以“0”开头的地址。从第一位到第8位作为网络标识，后24位相当于主机标识。
  * 十进制表示: 0.0.0.0 ~ 127.0.0.0
* B类地址
  * IP地址前两位为“10”的地址。从第1位到第16位作为网络标识,后16位相当于主机标识。
  * 十进制表示：128.0.0.0 ~191.255.0.0
* C类地址
  * IP地址是前三位为“110”的地址。从第1位到第24位作为网络标识，后8位相当于主机标识。
  * 十进制表示：192.0.0.0 ! 223.255.255.0
* D类地址
  * IP地址前四位为“1110”的地址。从第1位到第32位作为网络标识，D类地址没有主机标识，常被用于多播。
  * 十进制表示：224.0.0.0~239.255.255.255

### 广播地址

广播地址用于在同一个链路中相互连接的主机之间发送数据包。将IP地址中的主机地址部分全部设置为1，就成为了广播地址。

广播分为本地广播和直接广播：

* 在本网络内的广播叫做本地广播。
  * 该广播会被路由器屏蔽掉，不会到达其他网段的链路上。
* 在不同网络之间的广播叫做直接广播。
  * 例如192.168.0.0/24的主机向192.168.1.255/24的目标地址发送IP包。收到这个包的路由器会将数据转发给192.168.1.0/24,从而使得所有192.168.1.1~192.168.1.254的主机都能收到这个包。

![](https://github.com/daqi17/AndroidBlog/blob/master/img/%E7%BD%91%E7%BB%9C/IP/本地广播与直接广播.png)

### IP多播

> 多播用于将包发送给特定组内的所有主机。由于其直接使用IP协议，因此属于不可靠传输。

背景：向多台主机同时发送数据包，往往采用复制1对1通信的数据，将其同时发送给多个主机的方式。（广播无法穿透路由）

![](https://github.com/daqi17/AndroidBlog/blob/master/img/%E7%BD%91%E7%BB%9C/IP/多播.png)

​		多播使用D类地址，首位前4位位“1110”，剩下的28位可以成为多播的组编号。

​		224.0.0.0 ~224.0.0.255的范围不需要路由器控制，在同一个链路内也能够实现多播。该范围之外设置多播地址会给全网所有组内成员发送多播的包。

​		对于多播，所有的主机（路由器以外的主机和终端主机）必须属于224.0.0.1的组，所有的路由器必须属于224.0.0.2的组。

### 子网掩码

> IP地址的网络标识已不再受限于该地址的类别，而是由“子网掩码”的识别码通过子网网络地址细分出A类、B类、C类更小粒度的网络。
>
> 实际上就是将主机地址部分作为子网地址，可以将原网络分为多个物理网络的一种机制。

​		子网掩码用“1”表示IP网络地址的比特范围，用“0”表示IP主机地址范围。

### CIDR 和 VLSM(可变长子网掩码)

> CIDR ：采用任意长度分割IP地址的网络标识和主机标识

> VLSM：随意修改组织内各个部门的子网掩码长度

根据VLSM可以将网络地址划分为主机数为500个时，子网掩码长度为/23，主机数为50个时，子网掩码长度为/26。

### 私有地址

背景：由于互联网中任何一台主机或路由器必须配有一个唯一的IP地址。随着互联网的迅速普及，IP地址不足的问题日趋显著。

对于那些没有连接互联网的独立网络中的主机，只要保证在这个网络内地址唯一，可以不用考虑互联网即可配置相应的IP地址。但让每个独立的网络各自随意地设置IP地址，也可能会有问题。因此出现了私有网络的IP地址。

A类 ：10.0.0.0 ~ 10.255.255.255( 10/8 ) 

B类 ： 172.16.0.0 ~ 172.31.255.255 （172.16/12）

C类 ： 192.168.0.0  ~ 192.168.255.255 （192.168/16）

NAT技术将私有IP与全局IP互换，使配有私有地址的主机与配有全局地址的互联网主机实现了通信。

很多学校，公司内部采用每个终端设置私有IP，路由器或必要的服务器则设置全局IP地址的方法。配有私有IP的地址主机连网时，则通过NAT通信。

## 路由控制

### IP地址与路由控制

> IP地址的网络地址部分用于进行路由控制。

​		路由控制表形成方式有两种：一种是管理员手动设置（静态路由控制），另一种是路由器与其他路由器相互交换信息时自动刷新（动态路由控制）。在网络上互连的路由器之间必须设置好路由协议，保证正常读取路由控制信息，以确保让动态路由及时刷新路由表。

​		路由控制表中记录这网络地址与下一步应该发送至路由器的地址。在发送IP包时，首先要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。

​		当路由控制表中存在多条相同网络地址的记录，选择相同位数最多的。

### 路由表的聚合

​		对内即便有多个子网掩码，对外呈现出的也是同一个网络地址。这样能更好的构建网络，通过路由信息的聚合可以有效地减少路由表的条目。

​		路由表越大，管理它所需要的内存和CPU也越多。并且查找路由表的时间也越长，导致转发IP数据包的性能下降。如果想要构建大规模、高性能网络，则需要尽可能削减路由表的大小。

![](https://github.com/daqi17/AndroidBlog/blob/master/img/%E7%BD%91%E7%BB%9C/IP/路由器聚合.png)

## IP分割处理与再构成处理

### 数据链路不同，MTU则相异

每种数据链路的最大传输单元（MTU）都不尽相同。

![](https://github.com/daqi17/AndroidBlog/blob/master/img/%E7%BD%91%E7%BB%9C/IP/MTU.png)

### IP报文的分片与重组

任何一台主机都有必要对IP分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。

> 经过分片之后的IP数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。

原因：

1. 现实中无法保证IP数据报是否经由同一个路径传送。
2. 拆分后的每一个分片也有可能会在途中丢失。
3. 即便在途中某一处被重新组装，但如果下一站再经过其他路由时面临被分片的可能。（给路由器带来多余的负担，降低网络传送效率）

![](https://github.com/daqi17/AndroidBlog/blob/master/img/%E7%BD%91%E7%BB%9C/IP/分片.png)

**Ip首部中的“片偏移”字段表示分片之后每个分片在用户数据中的对应位置和该分片之后是否还有后续其他分片。根据这个字段可以判断一个IP数据报是否分片以及当前分片为整个数据报的起始、中段还有末尾。**

### 路径MTU发现

**分片机制问题：**

1. 随着时代的变迁，计算机网络的物理传输速度不断上升。
2. 另一方面，随着人们对网络安全的要求提高，路由器需要做的其他处理也越来越多，如网络过滤。因此，不希望由路由器进行IP数据包的分片处理。
3. 其次，一旦某个分片丢失，则会造成整个IP数据报作废。

**路径MTU发现**用于解决以上问题。

> 路径MTU是指：从发送端主机到接收端主机之间不需要分片时最大MTU的大小。
>
> 即路径中存在的所有数据链路中最小的MTU.

​		路径MTU发现从发送主机按照路径MTU的大小将数据报分片后进行发送。进行路径发现，就可以避免在中途的路由器上进行分片处理，也可以在TCP中发送更大的包。

**路径MTU发现的工作原理：**

1. 在发送端主机发送IP数据报时将其首部的分片禁止标志设置为1。当途中路由区需要分片时，会将包丢弃，并通过发送一个ICMP的不可达消息将数据链路上的MTU的值给发送端主机。
2. 将ICMP所通知的MTU值设置为当前MTU。发送主机根据这个MTU对数据报进行分片处理。
3. 如此反复，直到数据报被发送到目标主机为止没有再收到任何ICMP,就认为最后一此ICMP所通知的MTU值即是一个合适的MTU值。

​		在TCP的情况下，根据路径MTU的大小计算出最大段长度（MSS），然后再根据这些信息进行数据报的发送。

![](https://github.com/daqi17/AndroidBlog/blob/master/img/%E7%BD%91%E7%BB%9C/IP/路径MTU.png)

​		出于网络安全的考虑，有些域会限制ICMP消息的接收。这时路径MTU发现的功能无法正常运行，会造成最终用户不明，导致连接不稳定。

#### TCP的分段和IP的分片

传输层中的TCP会分段，网络层中的IP会分片。

IP层的分片更多的是为传输层的UDP服务。由于TCP自己会避免IP的分片，所以使用TCP传输在IP层都不会发送分片的现象。



> MTU = MSS + TCP首部 + IP首部

TCP分段过程中，每一个报文都包含TCP首部。

IP分片过程中，只有第一个分片包含TCP首部，其余只包含IP首部。

## IPv4头部

IP首部中包含着用于IP协议进行发包控制时所有的必要信息。了解IP首部，也就能够对IP所提供的功能有一个详细的把握。

![](https://github.com/daqi17/AndroidBlog/blob/master/img/%E7%BD%91%E7%BB%9C/IP/IPv4首部.png)

* 版本号

  * 4比特构成，表示标识IP首部的版本号（IPv4的版本号即为4）

* 首部长度

  * 4比特构成，表示IP首部的大小（实际为行数）。
  * IP报文每行32比特（4字节）。对于没有可选项的IP包，首部的长度则设置为“5”，5 * 4字节 = 20字节（IP报文最小长度为20字节）。

* 区分服务

  * 由8比特构成，表明服务质量。

  * |   比特    |    含义    |
      | :-------: | :--------: |
      |   0 1 2   |   优先度   |
      |     3     |  最低延迟  |
      |     4     |  最大吞吐  |
      |     5     | 最大可靠性 |
      |     6     |  最小代价  |
      | （3 ~ 6） |  最大安全  |
      |     7     |   未定义   |

    

* 总长度

  * IP首部与数据部分合起来的总字节数。该字段可表示最大长度为65535字节。

* 标识

  * 16比特构成，用于分片重组。
  * **同一分片的标识值相同，不同分片的标识值不同。**
  * 每发送一个IP包(数据报)，它的值也逐渐递增。（即便ID相同，但目标地址、源地址或者协议不同的话，也会被认为是不同的分片。）
  * 确定数据报的唯一性。使得数据报被分片后，在到达终点时终点能根据标识号将同一个数据报的分片重新组装成一个数据报。

* 标志

  * 3比特构成，标识包被分片的相关信息。

  * | 比特 |                             含义                             |
    | :--: | :----------------------------------------------------------: |
    |  0   |                       未使用，必须为0                        |
    |  1   |         指示是否进行分片 0 - 可以分片，1 - 不能分片          |
    |  2   | 包被分片的情况下，表示是否为最后一个包 0 - 最后一个分片包 1 - 分片中段的包 |

* 片偏移

  * 13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。
  * 第一个分片对应的值为0。由于片偏移域占13位，因此最多可以表示8192个相对位置。
  * 单位为8字节，因此最大可表示原始数据为65536字节的位置。
  * 分片本身还可能进行分片，这种情况下，**分片偏移值永远是相对于原始数据报的。**

* 生存时间

  * 8比特构成，指可以中转多少个路由器的意思。
  * 每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。

* 协议

  * 8比特，表示IP包传输层的上层协议编号。

  * | 分配编号 | 简称 |
    | :------: | :--: |
    |    1     | ICMP |
    |    2     | IGMP |
    |    6     | TCP  |
    |    17    | UDP  |

* 首部校验和

  * 16比特构成，确保IP数据报不被破坏。
  * 该字段只校验数据报的首部，不校验数据部分。

* 源地址

  * 32比特，表示发送端IP地址。

* 目标地址

  * 32比特，表示接收端IP地址。

* 可选项

  * 长度可变，通常只在进行实验或诊断时使用。
  * 包含如下几点信息：安全级别，源路径，路径记录，时间戳。

* 填充

  * 用0填充。

* 数据

  * 存入数据，将IP上层协议的首部也作为数据进行处理。

## IPv6头部

![](https://github.com/daqi17/AndroidBlog/blob/master/img/%E7%BD%91%E7%BB%9C/IP/IPv6.png)

IPv6为了减轻路由器的负担，省略了首部校验和字段。因此路由器不需要计算校验和，从而也提高了包的转发效率。（因为TCP和UDP在做校验和计算的时候使用伪首部，所以可以验证IP地址或协议是否正。因此，即便IP层无法提供可靠传输，在TCP或UDP层也可以提供可靠传输的服务。）

* 版本 
  * 值为6
* 通信量类
  * 相当于IPv4的区分服务字段，8比特构成。
* 流标号
  * 20比特构成，准备用于服务质量控制。
* 有效载荷长度
  * 有效载荷是指包的数据部分。（不包含首部，只表示数据部分的长度）
* 下一个首部
  * 相当于IPv4中协议字段，8比特。
  * 表示IP的上一层协议是TCP或UDP
  * 不过在有IPv6扩展首部的情况下，该字段表示后面第一个扩展首部的协议类型。
* 源地址
  * 128比特（8个16位字节），表示发送端IP地址。
* 目标地址
  * 128比特（8个16位字节），表示接收端IP地址。
* 扩展首部
  * 当需要对IPv6的数据进行分片是，可以设置为扩展域为44.

## 参考资料

[《图解TCP/IP》](https://github.com/daqi17/AndroidBlog/blob/master/%E7%94%B5%E5%AD%90%E4%B9%A6/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP%20IP(%E7%AC%AC5%E7%89%88).pdf)